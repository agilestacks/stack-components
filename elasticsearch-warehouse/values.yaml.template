# Copyright 2019 Viasat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# A copy of the License is located at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# or in the "license" file accompanying this file. This file is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language governing
# permissions and limitations under the License.

kibana:
  enabled: true
  image: amazon/opendistro-for-elasticsearch-kibana
  imageTag: 1.6.0
  replicas: 1
  port: 5601
  externalPort: 80
  resources: {}
  #  limits:
  #    cpu: 2500m
  #    memory: 2Gi
  #  requests:
  #    cpu: 500m
  #    memory: 512Mi
  readinessProbe: []
  livenessProbe: []

  elasticsearchAccount:
    secret: ""
    keyPassphrase:
      enabled: false

  extraEnvs: []

  ssl:
    kibana:
      enabled: false
      existingCertSecret:
    elasticsearch:
      enabled: true
      existingCertSecret: rest-certs

  configDirectory: "/usr/share/kibana/config"
  certsDirectory: "/usr/share/kibana/certs"

  ingress:
    ## Set to true to enable ingress record generation
    enabled: true
    annotations:
      #kubernetes.io/ingress.class: traefik
      kubernetes.io/tls-acme: "true"
    labels: {}
    path: /
    hosts:
    - {{component.elasticsearch.kibana.fqdn}}
    tls:
    - secretName: {{component.elasticsearch.name}}-kibana-tls
      hosts:
        - {{component.elasticsearch.kibana.fqdn}}

  service:
    type: ClusterIP
    annotations: {}

  config:
    ## Default Kibana configuration from kibana-docker.
    server.name: kibana
    server.host: "0"

    ## Replace with Elasticsearch DNS name picked during Service deployment
    elasticsearch.hosts: {{component.elasticsearch.api.url.internal}}
    elasticsearch.requestTimeout: 360000

    ## Kibana TLS Config
    server.ssl.enabled: false
    #server.ssl.key: /usr/share/kibana/certs/kibana-key.pem
    #server.ssl.certificate: /usr/share/kibana/certs/kibana-crt.pem
    elasticsearch.ssl.certificateAuthorities: ["/usr/share/kibana/certs/elk-rest-root-ca.pem"]
    elasticsearch.ssl.verificationMode: "none"

    elasticsearch.username: kibanaserver
    elasticsearch.password: kibanaserver
    elasticsearch.requestHeadersWhitelist: ["securitytenant","Authorization"]
    opendistro_security.multitenancy.enabled: false
    #opendistro_security.multitenancy.tenants.enable_global: true
    #opendistro_security.multitenancy.tenants.enable_private: true
    #opendistro_security.multitenancy.tenants.preferred: ["Private", "Global"]
    #opendistro_security.multitenancy.enable_filter: false

    opendistro_security.cookie.secure: true
    opendistro_security.cookie.password: {{component.elasticsearch.kibana.cookieKey}}

    opendistro_security.auth.anonymous_auth_enabled: true

    # openid stuff
    #opendistro_security.auth.type: openid
    #opendistro_security.openid.connect_url: {{component.dex.issuer}}/.well-known/openid-configuration
    #opendistro_security.openid.client_id: {{component.elasticsearch.name}}-kibana
    #opendistro_security.openid.client_secret: {{component.elasticsearch.kibana.openIdSecret}}
    #opendistro_security.openid.base_redirect_url: {{component.elasticsearch.kibana.url}}
    #opendistro_security.openid.logout_url: {{component.elasticsearch.signout.url}}

  ## Node labels for pod assignment
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  #
  nodeSelector: {}

  ## Tolerations for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##

  tolerations: []

  affinity: {}

  serviceAccount:
    ## Specifies whether a ServiceAccount should be created
    create: true
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:


global:
  clusterName: elasticsearch

  psp:
    create: true

  rbac:
    enabled: true
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  # imagePullSecrets:
  #   - myRegistryKeySecretName


elasticsearch:
  ## Used when deploying hot/warm architecture. Allows second aliased deployment to find cluster.
  ## Default {{ template opendistro-es.fullname }}-discovery.
  discoveryOverride: ""
  securityConfig:
    enabled: true
    path: "/usr/share/elasticsearch/plugins/opendistro_security/securityconfig"
    actionGroupsSecret: es-security-config
    configSecret: es-security-config
    internalUsersSecret: es-security-config
    rolesSecret: es-security-config
    rolesMappingSecret: es-security-config
    tenantsSecret: es-security-config

  extraEnvs: []

  initContainer:
    image: busybox
    imageTag: 1.27.2

  ssl:
    ## TLS is mandatory for the transport layer and can not be disabled
    transport:
      existingCertSecret: transport-certs
    rest:
      enabled: true
      existingCertSecret: rest-certs
    admin:
      enabled: true
      existingCertSecret: admin-certs

  master:
    enabled: true
    replicas: {{component.elasticsearch.master.replicas}}
    updateStrategy: "RollingUpdate"

    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    persistence:
      enabled: true
      ## A manually managed Persistent Volume and Claim
      ## Requires persistence.enabled: true
      ## If defined, PVC must be created manually before volume will be bound
      ##
      # existingClaim:

      ## The subdirectory of the volume to mount to, useful in dev environments
      ## and one PV for multiple services.
      ##
      subPath: ""

      ## Open Distro master Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      storageClass: {{component.elasticsearch.master.storageClass}}
      accessModes:
        - ReadWriteOnce
      size: {{component.elasticsearch.master.volumeSize}}
      annotations: {}

    resources:
      limits:
        cpu: {{component.elasticsearch.master.resources.cpu.limits}}
        memory: {{component.elasticsearch.master.resources.mem.limits}}
      requests:
        cpu: {{component.elasticsearch.master.resources.cpu.requests}}
        memory: {{component.elasticsearch.master.resources.mem.requests}}
    javaOpts: {{component.elasticsearch.master.javaOpts}}
    podDisruptionBudget:
      enabled: false
      minAvailable: 1
    readinessProbe: []
    livenessProbe:
      tcpSocket:
        port: transport
      initialDelaySeconds: 60
      periodSeconds: 10
    nodeSelector: {}
    tolerations: []
    ## Anti-affinity to disallow deploying client and master nodes on the same worker node
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              topologyKey: "kubernetes.io/hostname"
              labelSelector:
                matchExpressions:
                - key: role
                  operator: In
                  values:
                  - client
                  - master
                  - data
    podAnnotations: {}

  data:
    enabled: true
    replicas: {{component.elasticsearch.dataNode.replicas}}
    updateStrategy: "RollingUpdate"

    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    persistence:
      enabled: true
      ## A manually managed Persistent Volume and Claim
      ## Requires persistence.enabled: true
      ## If defined, PVC must be created manually before volume will be bound
      ##
      # existingClaim:

      ## The subdirectory of the volume to mount to, useful in dev environments
      ## and one PV for multiple services.
      ##
      subPath: ""

      ## Open Distro master Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      storageClass: {{component.elasticsearch.dataNode.storageClass}}
      accessModes:
        - ReadWriteOnce
      size: {{component.elasticsearch.dataNode.volumeSize}}
      annotations: {}

    resources:
      limits:
        cpu: {{component.elasticsearch.dataNode.resources.cpu.limits}}
        memory: {{component.elasticsearch.dataNode.resources.mem.limits}}
      requests:
        cpu: {{component.elasticsearch.dataNode.resources.cpu.requests}}
        memory: {{component.elasticsearch.dataNode.resources.mem.requests}}
    javaOpts: {{component.elasticsearch.dataNode.javaOpts}}
    podDisruptionBudget:
      enabled: false
      minAvailable: 1
    readinessProbe: []
    livenessProbe:
      tcpSocket:
        port: transport
      initialDelaySeconds: 60
      periodSeconds: 10
    nodeSelector: {}
    tolerations: []
    ## Anti-affinity to disallow deploying client and master nodes on the same worker node
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              topologyKey: "kubernetes.io/hostname"
              labelSelector:
                matchExpressions:
                - key: role
                  operator: In
                  values:
                  - client
                  - master
                  - data
    podAnnotations: {}

  client:
    enabled: true
    service:
      type: ClusterIP
      annotations: {}
        # # Defined ELB backend protocol as HTTPS to allow connection to Elasticsearch API
        # service.beta.kubernetes.io/aws-load-balancer-backend-protocol: https

        # # ARN of ACM certificate registered to the deployed ELB for handling connections over TLS
        # # ACM certificate should be issued to the DNS hostname defined earlier (elk.sec.example.com)
        # service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:us-east-1:111222333444:certificate/c69f6022-b24f-43d9-b9c8-dfe288d9443d"
        # service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"

        # service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
        # service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"
        # service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"

        # # Annotation to create internal only ELB
        # service.beta.kubernetes.io/aws-load-balancer-internal: 0.0.0.0/0
    replicas: {{component.elasticsearch.client.replicas}}
    ingress:
      ## Set to true to enable ingress record generation
      enabled: true
      annotations:
        traefik.protocol: https
      #  kubernetes.io/ingress.class: nginx
        kubernetes.io/tls-acme: "true"
      labels: {}
      path: /
      hosts:
      - {{component.elasticsearch.api.fqdn}}
      tls:
      - secretName: {{component.elasticsearch.name}}-client-tls
        hosts:
        - {{component.elasticsearch.api.fqdn}}
    resources:
      limits:
        cpu: {{component.elasticsearch.client.resources.cpu.limits}}
        memory: {{component.elasticsearch.client.resources.mem.limits}}
      requests:
        cpu: {{component.elasticsearch.client.resources.cpu.requests}}
        memory: {{component.elasticsearch.client.resources.mem.requests}}
    javaOpts: {{component.elasticsearch.client.javaOpts}}
    podDisruptionBudget:
      enabled: false
      minAvailable: 1
    readinessProbe: []
    livenessProbe:
      tcpSocket:
        port: transport
      initialDelaySeconds: 60
      periodSeconds: 10
    nodeSelector: {}
    tolerations: []
    ## Weighted anti-affinity to disallow deploying client node to the same worker node as master node
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              topologyKey: "kubernetes.io/hostname"
              labelSelector:
                matchExpressions:
                - key: role
                  operator: In
                  values:
                  - client
                  - master
                  - data
    podAnnotations: {}

  config:
    opendistro_security.allow_unsafe_democertificates: false
    opendistro_security.allow_default_init_securityindex: true
    opendistro_security.enable_snapshot_restore_privilege: true
    opendistro_security.roles_mapping_resolution: MAPPING_ONLY
    opendistro_security.audit.type: internal_elasticsearch
    opendistro_security.enable_snapshot_restore_privilege: true
    opendistro_security.check_snapshot_restore_write_privileges: true
    opendistro_security.restapi.roles_enabled: ["all_access", "security_rest_api_access"]
    cluster.routing.allocation.disk.threshold_enabled: false

    cluster:
      name: {{component.elasticsearch.name}}

    network.host: "0.0.0.0"
    bootstrap.memory_lock: false

    path:
      data: /usr/share/elasticsearch/data
      logs: /usr/share/elasticsearch/logs

    http:
      compression: true

    opendistro_security.ssl.transport.pemcert_filepath: elk-transport-crt.pem
    opendistro_security.ssl.transport.pemkey_filepath: elk-transport-key.pem
    opendistro_security.ssl.transport.pemtrustedcas_filepath: elk-transport-root-ca.pem
    opendistro_security.ssl.transport.enforce_hostname_verification: false

    opendistro_security.ssl.http.enabled: true

    opendistro_security.ssl.http.pemcert_filepath: elk-rest-crt.pem
    opendistro_security.ssl.http.pemkey_filepath: elk-rest-key.pem
    opendistro_security.ssl.http.pemtrustedcas_filepath: elk-rest-root-ca.pem
    opendistro_security.authcz.admin_dn:
    - "{{component.elasticsearch.tls.admin.subject}}"
    opendistro_security.nodes_dn:
    - "{{component.elasticsearch.tls.node.subject}}"

  log4jConfig: ""

  loggingConfig:
    ## Default config
    ## you can override this using by setting a system property, for example -Des.logger.level=DEBUG
    es.logger.level: INFO
    rootLogger: ${es.logger.level}, console
    logger:
      ## log action execution errors for easier debugging
      action: DEBUG
      ## reduce the logging for aws, too much is logged under the default INFO
      com.amazonaws: WARN
    appender:
      console:
        type: console
        layout:
          type: consolePattern
          conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %m%n"

  transportKeyPassphrase:
    enabled: false
    passPhrase:

  sslKeyPassphrase:
    enabled: false
    passPhrase:

  maxMapCount: 262144

  image: amazon/opendistro-for-elasticsearch
  imageTag: 1.6.0
  ## Specifies the image pull policy. Can be "Always" or "IfNotPresent" or "Never".
  ## Default to "Always".
  imagePullPolicy: ""

  configDirectory: /usr/share/elasticsearch/config

  serviceAccount:
    ## Specifies whether a ServiceAccount should be created
    create: true
    ## The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the fullname template
    name:


nameOverride: ""
fullnameOverride: ""
